/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AudioModel
 */
export interface AudioModel {
    /**
     * 
     * @type {string}
     * @memberof AudioModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AudioModel
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof AudioModel
     */
    'file_name': string;
    /**
     * 
     * @type {number}
     * @memberof AudioModel
     */
    'audio_length': number;
}
/**
 * 
 * @export
 * @interface BindingEntry
 */
export interface BindingEntry {
    /**
     * 
     * @type {string}
     * @memberof BindingEntry
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BindingEntry
     */
    'category_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof BindingEntry
     */
    'audio_id': string;
    /**
     * 
     * @type {string}
     * @memberof BindingEntry
     */
    'text_id': string;
}
/**
 * 
 * @export
 * @interface BindingModel
 */
export interface BindingModel {
    /**
     * 
     * @type {BindingEntry}
     * @memberof BindingModel
     */
    'binding': BindingEntry;
    /**
     * 
     * @type {CategoryModel}
     * @memberof BindingModel
     */
    'category': CategoryModel | null;
    /**
     * 
     * @type {AudioModel}
     * @memberof BindingModel
     */
    'audio': AudioModel;
    /**
     * 
     * @type {TextModel}
     * @memberof BindingModel
     */
    'text': TextModel;
}
/**
 * 
 * @export
 * @interface CategoryModel
 */
export interface CategoryModel {
    /**
     * 
     * @type {string}
     * @memberof CategoryModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface DashboardModel
 */
export interface DashboardModel {
    /**
     * 
     * @type {number}
     * @memberof DashboardModel
     */
    'categories_count': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardModel
     */
    'total_bindings_count': number;
    /**
     * 
     * @type {Array<any>}
     * @memberof DashboardModel
     */
    'category_with_most_bindings': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof DashboardModel
     */
    'uncategorizaed_count': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardModel
     */
    'categorized_count': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardModel
     */
    'total_audio_duration': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardModel
     */
    'filled_transcript_count': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardModel
     */
    'empty_transcript_count': number;
}
/**
 * 
 * @export
 * @interface DirectoryModel
 */
export interface DirectoryModel {
    /**
     * 
     * @type {string}
     * @memberof DirectoryModel
     */
    'dir_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof DirectoryModel
     */
    'is_dir': DirectoryModelIsDirEnum;
    /**
     * 
     * @type {Array<DirectoryModelFilesInner>}
     * @memberof DirectoryModel
     */
    'files': Array<DirectoryModelFilesInner>;
}

export const DirectoryModelIsDirEnum = {
    True: true
} as const;

export type DirectoryModelIsDirEnum = typeof DirectoryModelIsDirEnum[keyof typeof DirectoryModelIsDirEnum];

/**
 * 
 * @export
 * @interface DirectoryModelFilesInner
 */
export interface DirectoryModelFilesInner {
    /**
     * 
     * @type {string}
     * @memberof DirectoryModelFilesInner
     */
    'file_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof DirectoryModelFilesInner
     */
    'is_dir': DirectoryModelFilesInnerIsDirEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectoryModelFilesInner
     */
    'dir_name': string;
    /**
     * 
     * @type {Array<DirectoryModelFilesInner>}
     * @memberof DirectoryModelFilesInner
     */
    'files': Array<DirectoryModelFilesInner>;
}

export const DirectoryModelFilesInnerIsDirEnum = {
    True: true
} as const;

export type DirectoryModelFilesInnerIsDirEnum = typeof DirectoryModelFilesInnerIsDirEnum[keyof typeof DirectoryModelFilesInnerIsDirEnum];

/**
 * 
 * @export
 * @interface FileModel
 */
export interface FileModel {
    /**
     * 
     * @type {string}
     * @memberof FileModel
     */
    'file_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof FileModel
     */
    'is_dir': FileModelIsDirEnum;
}

export const FileModelIsDirEnum = {
    False: false
} as const;

export type FileModelIsDirEnum = typeof FileModelIsDirEnum[keyof typeof FileModelIsDirEnum];

/**
 * 
 * @export
 * @interface FinaliseConfigModel
 */
export interface FinaliseConfigModel {
    /**
     * 
     * @type {boolean}
     * @memberof FinaliseConfigModel
     */
    'omit_empty'?: boolean;
    /**
     *       supported keys:          {file} - file name          {category} - category name          {category_index} - category index (created automatically)          {text} - text of entry          {duration} - duration of audio in seconds      
     * @type {string}
     * @memberof FinaliseConfigModel
     */
    'line_format'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FinaliseConfigModel
     */
    'divide_by_category'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FinaliseConfigModel
     */
    'category_to_lower'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FinaliseConfigModel
     */
    'category_space_replacer'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FinaliseConfigModel
     */
    'export_transcript'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FinaliseConfigModel
     */
    'uncaterized_name'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface PaginatedBindingModel
 */
export interface PaginatedBindingModel {
    /**
     * 
     * @type {Array<BindingModel>}
     * @memberof PaginatedBindingModel
     */
    'bindings': Array<BindingModel>;
    /**
     * 
     * @type {PaginationModel}
     * @memberof PaginatedBindingModel
     */
    'pagination': PaginationModel;
    /**
     * 
     * @type {number}
     * @memberof PaginatedBindingModel
     */
    'page': number;
}
/**
 * 
 * @export
 * @interface PaginationModel
 */
export interface PaginationModel {
    /**
     * 
     * @type {number}
     * @memberof PaginationModel
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface TextModel
 */
export interface TextModel {
    /**
     * 
     * @type {string}
     * @memberof TextModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TextModel
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete audio file from both MinIO and database
         * @summary Delete Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAudioAudioAudioIdDelete: async (audioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('deleteAudioAudioAudioIdDelete', 'audioId', audioId)
            const localVarPath = `/audio/{audio_id}`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download audio file by UUID
         * @summary Download Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAudioAudioDownloadAudioIdGet: async (audioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('downloadAudioAudioDownloadAudioIdGet', 'audioId', audioId)
            const localVarPath = `/audio/download/{audio_id}`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Url
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUrlAudioDownloadAudioIdUrlGet: async (audioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('downloadUrlAudioDownloadAudioIdUrlGet', 'audioId', audioId)
            const localVarPath = `/audio/download/{audio_id}/url`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get presigned URL for audio file access
         * @summary Get Audio Url
         * @param {string} audioId 
         * @param {number} [expires] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioUrlAudioUrlAudioIdGet: async (audioId: string, expires?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('getAudioUrlAudioUrlAudioIdGet', 'audioId', audioId)
            const localVarPath = `/audio/url/{audio_id}`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expires !== undefined) {
                localVarQueryParameter['expires'] = expires;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload audio file to MinIO and save metadata to database
         * @summary Upload Audio
         * @param {File} file 
         * @param {string} [uuid] 
         * @param {string} [folder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAudioAudioUploadPost: async (file: File, uuid?: string, folder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadAudioAudioUploadPost', 'file', file)
            const localVarPath = `/audio/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (folder !== undefined) {
                localVarQueryParameter['folder'] = folder;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudioApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete audio file from both MinIO and database
         * @summary Delete Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAudioAudioAudioIdDelete(audioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAudioAudioAudioIdDelete(audioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.deleteAudioAudioAudioIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download audio file by UUID
         * @summary Download Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAudioAudioDownloadAudioIdGet(audioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAudioAudioDownloadAudioIdGet(audioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.downloadAudioAudioDownloadAudioIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Url
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadUrlAudioDownloadAudioIdUrlGet(audioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadUrlAudioDownloadAudioIdUrlGet(audioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.downloadUrlAudioDownloadAudioIdUrlGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get presigned URL for audio file access
         * @summary Get Audio Url
         * @param {string} audioId 
         * @param {number} [expires] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioUrlAudioUrlAudioIdGet(audioId: string, expires?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAudioUrlAudioUrlAudioIdGet(audioId, expires, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.getAudioUrlAudioUrlAudioIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload audio file to MinIO and save metadata to database
         * @summary Upload Audio
         * @param {File} file 
         * @param {string} [uuid] 
         * @param {string} [folder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAudioAudioUploadPost(file: File, uuid?: string, folder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudioModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAudioAudioUploadPost(file, uuid, folder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.uploadAudioAudioUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudioApiFp(configuration)
    return {
        /**
         * Delete audio file from both MinIO and database
         * @summary Delete Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAudioAudioAudioIdDelete(audioId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteAudioAudioAudioIdDelete(audioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Download audio file by UUID
         * @summary Download Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAudioAudioDownloadAudioIdGet(audioId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadAudioAudioDownloadAudioIdGet(audioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Url
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadUrlAudioDownloadAudioIdUrlGet(audioId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadUrlAudioDownloadAudioIdUrlGet(audioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get presigned URL for audio file access
         * @summary Get Audio Url
         * @param {string} audioId 
         * @param {number} [expires] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioUrlAudioUrlAudioIdGet(audioId: string, expires?: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getAudioUrlAudioUrlAudioIdGet(audioId, expires, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload audio file to MinIO and save metadata to database
         * @summary Upload Audio
         * @param {File} file 
         * @param {string} [uuid] 
         * @param {string} [folder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAudioAudioUploadPost(file: File, uuid?: string, folder?: string, options?: RawAxiosRequestConfig): AxiosPromise<AudioModel> {
            return localVarFp.uploadAudioAudioUploadPost(file, uuid, folder, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI {
    /**
     * Delete audio file from both MinIO and database
     * @summary Delete Audio
     * @param {string} audioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public deleteAudioAudioAudioIdDelete(audioId: string, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).deleteAudioAudioAudioIdDelete(audioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download audio file by UUID
     * @summary Download Audio
     * @param {string} audioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public downloadAudioAudioDownloadAudioIdGet(audioId: string, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).downloadAudioAudioDownloadAudioIdGet(audioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Url
     * @param {string} audioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public downloadUrlAudioDownloadAudioIdUrlGet(audioId: string, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).downloadUrlAudioDownloadAudioIdUrlGet(audioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get presigned URL for audio file access
     * @summary Get Audio Url
     * @param {string} audioId 
     * @param {number} [expires] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAudioUrlAudioUrlAudioIdGet(audioId: string, expires?: number, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).getAudioUrlAudioUrlAudioIdGet(audioId, expires, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload audio file to MinIO and save metadata to database
     * @summary Upload Audio
     * @param {File} file 
     * @param {string} [uuid] 
     * @param {string} [folder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public uploadAudioAudioUploadPost(file: File, uuid?: string, folder?: string, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).uploadAudioAudioUploadPost(file, uuid, folder, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BindingsApi - axios parameter creator
 * @export
 */
export const BindingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Binding Category Remove
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut: async (bindingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bindingId' is not null or undefined
            assertParamExists('bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut', 'bindingId', bindingId)
            const localVarPath = `/bindings/{binding_id}/remove_category`
                .replace(`{${"binding_id"}}`, encodeURIComponent(String(bindingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Binding Category Update
         * @param {string} bindingId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut: async (bindingId: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bindingId' is not null or undefined
            assertParamExists('bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut', 'bindingId', bindingId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut', 'categoryId', categoryId)
            const localVarPath = `/bindings/{binding_id}/category_assign/{category_id}`
                .replace(`{${"binding_id"}}`, encodeURIComponent(String(bindingId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Binding
         * @param {File} audio 
         * @param {string | null} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBindingBindingsPost: async (audio: File, category?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audio' is not null or undefined
            assertParamExists('createBindingBindingsPost', 'audio', audio)
            const localVarPath = `/bindings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


            if (audio !== undefined) { 
                localVarFormParams.append('audio', audio as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Bindings
         * @param {string | null} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBindingsBindingsAllGet: async (category?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bindings/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountBindingsCountGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bindings/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Paginated Bindings
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBindingsBindingsGet: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bindings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBindingBindingsBindingIdDelete: async (bindingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bindingId' is not null or undefined
            assertParamExists('removeBindingBindingsBindingIdDelete', 'bindingId', bindingId)
            const localVarPath = `/bindings/{binding_id}`
                .replace(`{${"binding_id"}}`, encodeURIComponent(String(bindingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BindingsApi - functional programming interface
 * @export
 */
export const BindingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BindingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Binding Category Remove
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut(bindingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut(bindingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Binding Category Update
         * @param {string} bindingId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Binding
         * @param {File} audio 
         * @param {string | null} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBindingBindingsPost(audio: File, category?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBindingBindingsPost(audio, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.createBindingBindingsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Bindings
         * @param {string | null} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBindingsBindingsAllGet(category?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BindingModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBindingsBindingsAllGet(category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.getAllBindingsBindingsAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountBindingsCountGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountBindingsCountGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.getCountBindingsCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Paginated Bindings
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaginatedBindingsBindingsGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBindingModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaginatedBindingsBindingsGet(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.getPaginatedBindingsBindingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBindingBindingsBindingIdDelete(bindingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBindingBindingsBindingIdDelete(bindingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.removeBindingBindingsBindingIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BindingsApi - factory interface
 * @export
 */
export const BindingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BindingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Binding Category Remove
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut(bindingId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut(bindingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Binding Category Update
         * @param {string} bindingId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId: string, categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Binding
         * @param {File} audio 
         * @param {string | null} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBindingBindingsPost(audio: File, category?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createBindingBindingsPost(audio, category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Bindings
         * @param {string | null} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBindingsBindingsAllGet(category?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<BindingModel>> {
            return localVarFp.getAllBindingsBindingsAllGet(category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountBindingsCountGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getCountBindingsCountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Paginated Bindings
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBindingsBindingsGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBindingModel> {
            return localVarFp.getPaginatedBindingsBindingsGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBindingBindingsBindingIdDelete(bindingId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.removeBindingBindingsBindingIdDelete(bindingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BindingsApi - object-oriented interface
 * @export
 * @class BindingsApi
 * @extends {BaseAPI}
 */
export class BindingsApi extends BaseAPI {
    /**
     * 
     * @summary Binding Category Remove
     * @param {string} bindingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut(bindingId: string, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).bindingCategoryRemoveBindingsBindingIdRemoveCategoryPut(bindingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Binding Category Update
     * @param {string} bindingId 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId: string, categoryId: string, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Binding
     * @param {File} audio 
     * @param {string | null} [category] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public createBindingBindingsPost(audio: File, category?: string | null, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).createBindingBindingsPost(audio, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Bindings
     * @param {string | null} [category] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public getAllBindingsBindingsAllGet(category?: string | null, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).getAllBindingsBindingsAllGet(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public getCountBindingsCountGet(options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).getCountBindingsCountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Paginated Bindings
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public getPaginatedBindingsBindingsGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).getPaginatedBindingsBindingsGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Binding
     * @param {string} bindingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public removeBindingBindingsBindingIdDelete(bindingId: string, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).removeBindingBindingsBindingIdDelete(bindingId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get All Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategoriesCategoriesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post New Category
         * @param {string} category 
         * @param {string | null} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewCategoryCategoriesPost: async (category: string, id?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('postNewCategoryCategoriesPost', 'category', category)
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


            if (category !== undefined) { 
                localVarFormParams.set('category', category as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCategoryCategoriesCategoryNameDelete: async (categoryName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('removeCategoryCategoriesCategoryNameDelete', 'categoryName', categoryName)
            const localVarPath = `/categories/{category_name}`
                .replace(`{${"category_name"}}`, encodeURIComponent(String(categoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Category
         * @param {string} id 
         * @param {string} newCategoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryCategoriesIdPatch: async (id: string, newCategoryName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategoryCategoriesIdPatch', 'id', id)
            // verify required parameter 'newCategoryName' is not null or undefined
            assertParamExists('updateCategoryCategoriesIdPatch', 'newCategoryName', newCategoryName)
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (newCategoryName !== undefined) { 
                localVarFormParams.set('new_category_name', newCategoryName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get All Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategoriesCategoriesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategoriesCategoriesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.getAllCategoriesCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Post New Category
         * @param {string} category 
         * @param {string | null} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewCategoryCategoriesPost(category: string, id?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewCategoryCategoriesPost(category, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.postNewCategoryCategoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCategoryCategoriesCategoryNameDelete(categoryName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCategoryCategoriesCategoryNameDelete(categoryName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.removeCategoryCategoriesCategoryNameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Category
         * @param {string} id 
         * @param {string} newCategoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategoryCategoriesIdPatch(id: string, newCategoryName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategoryCategoriesIdPatch(id, newCategoryName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.updateCategoryCategoriesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get All Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategoriesCategoriesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<CategoryModel>> {
            return localVarFp.getAllCategoriesCategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post New Category
         * @param {string} category 
         * @param {string | null} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewCategoryCategoriesPost(category: string, id?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.postNewCategoryCategoriesPost(category, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCategoryCategoriesCategoryNameDelete(categoryName: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.removeCategoryCategoriesCategoryNameDelete(categoryName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Category
         * @param {string} id 
         * @param {string} newCategoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryCategoriesIdPatch(id: string, newCategoryName: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.updateCategoryCategoriesIdPatch(id, newCategoryName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @summary Get All Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getAllCategoriesCategoriesGet(options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).getAllCategoriesCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post New Category
     * @param {string} category 
     * @param {string | null} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public postNewCategoryCategoriesPost(category: string, id?: string | null, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).postNewCategoryCategoriesPost(category, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Category
     * @param {string} categoryName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public removeCategoryCategoriesCategoryNameDelete(categoryName: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).removeCategoryCategoriesCategoryNameDelete(categoryName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Category
     * @param {string} id 
     * @param {string} newCategoryName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public updateCategoryCategoriesIdPatch(id: string, newCategoryName: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).updateCategoryCategoriesIdPatch(id, newCategoryName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardDashboardGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardDashboardGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardDashboardGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboardDashboardGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardDashboardGet(options?: RawAxiosRequestConfig): AxiosPromise<DashboardModel> {
            return localVarFp.getDashboardDashboardGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @summary Get Dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardDashboardGet(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardDashboardGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FinaliseApi - axios parameter creator
 * @export
 */
export const FinaliseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finalise
         * @param {FinaliseConfigModel} finaliseConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finaliseFinalisePost: async (finaliseConfigModel: FinaliseConfigModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'finaliseConfigModel' is not null or undefined
            assertParamExists('finaliseFinalisePost', 'finaliseConfigModel', finaliseConfigModel)
            const localVarPath = `/finalise/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finaliseConfigModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FinaliseApi - functional programming interface
 * @export
 */
export const FinaliseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FinaliseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Finalise
         * @param {FinaliseConfigModel} finaliseConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finaliseFinalisePost(finaliseConfigModel: FinaliseConfigModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finaliseFinalisePost(finaliseConfigModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FinaliseApi.finaliseFinalisePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FinaliseApi - factory interface
 * @export
 */
export const FinaliseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FinaliseApiFp(configuration)
    return {
        /**
         * 
         * @summary Finalise
         * @param {FinaliseConfigModel} finaliseConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finaliseFinalisePost(finaliseConfigModel: FinaliseConfigModel, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryModel> {
            return localVarFp.finaliseFinalisePost(finaliseConfigModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FinaliseApi - object-oriented interface
 * @export
 * @class FinaliseApi
 * @extends {BaseAPI}
 */
export class FinaliseApi extends BaseAPI {
    /**
     * 
     * @summary Finalise
     * @param {FinaliseConfigModel} finaliseConfigModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinaliseApi
     */
    public finaliseFinalisePost(finaliseConfigModel: FinaliseConfigModel, options?: RawAxiosRequestConfig) {
        return FinaliseApiFp(this.configuration).finaliseFinalisePost(finaliseConfigModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextsApi - axios parameter creator
 * @export
 */
export const TextsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update Text
         * @param {string} textId 
         * @param {string} newText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextTextsTextIdPatch: async (textId: string, newText: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('updateTextTextsTextIdPatch', 'textId', textId)
            // verify required parameter 'newText' is not null or undefined
            assertParamExists('updateTextTextsTextIdPatch', 'newText', newText)
            const localVarPath = `/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newText !== undefined) {
                localVarQueryParameter['new_text'] = newText;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextsApi - functional programming interface
 * @export
 */
export const TextsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update Text
         * @param {string} textId 
         * @param {string} newText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTextTextsTextIdPatch(textId: string, newText: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTextTextsTextIdPatch(textId, newText, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextsApi.updateTextTextsTextIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextsApi - factory interface
 * @export
 */
export const TextsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextsApiFp(configuration)
    return {
        /**
         * 
         * @summary Update Text
         * @param {string} textId 
         * @param {string} newText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextTextsTextIdPatch(textId: string, newText: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.updateTextTextsTextIdPatch(textId, newText, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextsApi - object-oriented interface
 * @export
 * @class TextsApi
 * @extends {BaseAPI}
 */
export class TextsApi extends BaseAPI {
    /**
     * 
     * @summary Update Text
     * @param {string} textId 
     * @param {string} newText 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public updateTextTextsTextIdPatch(textId: string, newText: string, options?: RawAxiosRequestConfig) {
        return TextsApiFp(this.configuration).updateTextTextsTextIdPatch(textId, newText, options).then((request) => request(this.axios, this.basePath));
    }
}



