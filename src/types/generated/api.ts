/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AudioModel
 */
export interface AudioModel {
    /**
     * 
     * @type {string}
     * @memberof AudioModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AudioModel
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof AudioModel
     */
    'file_name': string;
    /**
     * 
     * @type {number}
     * @memberof AudioModel
     */
    'channels': number;
    /**
     * 
     * @type {number}
     * @memberof AudioModel
     */
    'frequency': number;
    /**
     * 
     * @type {number}
     * @memberof AudioModel
     */
    'audio_length': number;
}
/**
 * 
 * @export
 * @interface BindingEntry
 */
export interface BindingEntry {
    /**
     * 
     * @type {string}
     * @memberof BindingEntry
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BindingEntry
     */
    'category_id': string;
    /**
     * 
     * @type {string}
     * @memberof BindingEntry
     */
    'audio_id': string;
    /**
     * 
     * @type {string}
     * @memberof BindingEntry
     */
    'text_id': string;
}
/**
 * 
 * @export
 * @interface BindingModel
 */
export interface BindingModel {
    /**
     * 
     * @type {BindingEntry}
     * @memberof BindingModel
     */
    'binding': BindingEntry;
    /**
     * 
     * @type {CategoryModel}
     * @memberof BindingModel
     */
    'category': CategoryModel;
    /**
     * 
     * @type {AudioModel}
     * @memberof BindingModel
     */
    'audio': AudioModel;
    /**
     * 
     * @type {TextModel}
     * @memberof BindingModel
     */
    'text': TextModel;
}
/**
 * 
 * @export
 * @interface CategoryModel
 */
export interface CategoryModel {
    /**
     * 
     * @type {string}
     * @memberof CategoryModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryModel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface TextModel
 */
export interface TextModel {
    /**
     * 
     * @type {string}
     * @memberof TextModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TextModel
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get All Audios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAudiosAudiosGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/audios/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioAudiosAudioIdGet: async (audioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('getAudioAudiosAudioIdGet', 'audioId', audioId)
            const localVarPath = `/audios/{audio_id}`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post New Audio
         * @param {string} id 
         * @param {File} file 
         * @param {any} [commit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewAudioAudiosPost: async (id: string, file: File, commit?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postNewAudioAudiosPost', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postNewAudioAudiosPost', 'file', file)
            const localVarPath = `/audios/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (commit !== undefined) {
                for (const [key, value] of Object.entries(commit)) {
                    localVarQueryParameter[key] = value;
                }
            }


            if (id !== undefined) { 
                localVarFormParams.set('id', id as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.set('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAudioAudiosAudioIdDelete: async (audioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audioId' is not null or undefined
            assertParamExists('removeAudioAudiosAudioIdDelete', 'audioId', audioId)
            const localVarPath = `/audios/{audio_id}`
                .replace(`{${"audio_id"}}`, encodeURIComponent(String(audioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get All Audios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAudiosAudiosGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAudiosAudiosGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.getAllAudiosAudiosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioAudiosAudioIdGet(audioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAudioAudiosAudioIdGet(audioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.getAudioAudiosAudioIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Post New Audio
         * @param {string} id 
         * @param {File} file 
         * @param {any} [commit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewAudioAudiosPost(id: string, file: File, commit?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewAudioAudiosPost(id, file, commit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.postNewAudioAudiosPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAudioAudiosAudioIdDelete(audioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAudioAudiosAudioIdDelete(audioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.removeAudioAudiosAudioIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudioApiFp(configuration)
    return {
        /**
         * 
         * @summary Get All Audios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAudiosAudiosGet(options?: any): AxiosPromise<any> {
            return localVarFp.getAllAudiosAudiosGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioAudiosAudioIdGet(audioId: string, options?: any): AxiosPromise<any> {
            return localVarFp.getAudioAudiosAudioIdGet(audioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post New Audio
         * @param {string} id 
         * @param {File} file 
         * @param {any} [commit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewAudioAudiosPost(id: string, file: File, commit?: any, options?: any): AxiosPromise<any> {
            return localVarFp.postNewAudioAudiosPost(id, file, commit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Audio
         * @param {string} audioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAudioAudiosAudioIdDelete(audioId: string, options?: any): AxiosPromise<any> {
            return localVarFp.removeAudioAudiosAudioIdDelete(audioId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI {
    /**
     * 
     * @summary Get All Audios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAllAudiosAudiosGet(options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).getAllAudiosAudiosGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Audio
     * @param {string} audioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAudioAudiosAudioIdGet(audioId: string, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).getAudioAudiosAudioIdGet(audioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post New Audio
     * @param {string} id 
     * @param {File} file 
     * @param {any} [commit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public postNewAudioAudiosPost(id: string, file: File, commit?: any, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).postNewAudioAudiosPost(id, file, commit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Audio
     * @param {string} audioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public removeAudioAudiosAudioIdDelete(audioId: string, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).removeAudioAudiosAudioIdDelete(audioId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BindingsApi - axios parameter creator
 * @export
 */
export const BindingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Binding Category Update
         * @param {string} bindingId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut: async (bindingId: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bindingId' is not null or undefined
            assertParamExists('bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut', 'bindingId', bindingId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut', 'categoryId', categoryId)
            const localVarPath = `/bindings/{binding_id}/category_assign/{category_id}`
                .replace(`{${"binding_id"}}`, encodeURIComponent(String(bindingId)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Binding
         * @param {File} audio 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBindingBindingsPost: async (audio: File, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'audio' is not null or undefined
            assertParamExists('createBindingBindingsPost', 'audio', audio)
            const localVarPath = `/bindings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (audio !== undefined) { 
                localVarFormParams.append('audio', audio as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Bindings
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBindingsBindingsAllGet: async (category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bindings/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBindingBindingsBindingIdGet: async (bindingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bindingId' is not null or undefined
            assertParamExists('getBindingBindingsBindingIdGet', 'bindingId', bindingId)
            const localVarPath = `/bindings/{binding_id}`
                .replace(`{${"binding_id"}}`, encodeURIComponent(String(bindingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountBindingsCountGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bindings/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Paginated Bindings
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBindingsBindingsGet: async (page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bindings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBindingBindingsBindingIdDelete: async (bindingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bindingId' is not null or undefined
            assertParamExists('removeBindingBindingsBindingIdDelete', 'bindingId', bindingId)
            const localVarPath = `/bindings/{binding_id}`
                .replace(`{${"binding_id"}}`, encodeURIComponent(String(bindingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BindingsApi - functional programming interface
 * @export
 */
export const BindingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BindingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Binding Category Update
         * @param {string} bindingId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Binding
         * @param {File} audio 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBindingBindingsPost(audio: File, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBindingBindingsPost(audio, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.createBindingBindingsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Bindings
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBindingsBindingsAllGet(category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BindingModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBindingsBindingsAllGet(category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.getAllBindingsBindingsAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBindingBindingsBindingIdGet(bindingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BindingModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBindingBindingsBindingIdGet(bindingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.getBindingBindingsBindingIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountBindingsCountGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountBindingsCountGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.getCountBindingsCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Paginated Bindings
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaginatedBindingsBindingsGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BindingModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaginatedBindingsBindingsGet(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.getPaginatedBindingsBindingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBindingBindingsBindingIdDelete(bindingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBindingBindingsBindingIdDelete(bindingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BindingsApi.removeBindingBindingsBindingIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BindingsApi - factory interface
 * @export
 */
export const BindingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BindingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Binding Category Update
         * @param {string} bindingId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId: string, categoryId: string, options?: any): AxiosPromise<any> {
            return localVarFp.bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Binding
         * @param {File} audio 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBindingBindingsPost(audio: File, category?: string, options?: any): AxiosPromise<any> {
            return localVarFp.createBindingBindingsPost(audio, category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Bindings
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBindingsBindingsAllGet(category?: string, options?: any): AxiosPromise<Array<BindingModel>> {
            return localVarFp.getAllBindingsBindingsAllGet(category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBindingBindingsBindingIdGet(bindingId: string, options?: any): AxiosPromise<BindingModel> {
            return localVarFp.getBindingBindingsBindingIdGet(bindingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountBindingsCountGet(options?: any): AxiosPromise<any> {
            return localVarFp.getCountBindingsCountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Paginated Bindings
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedBindingsBindingsGet(page?: number, perPage?: number, options?: any): AxiosPromise<Array<BindingModel>> {
            return localVarFp.getPaginatedBindingsBindingsGet(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Binding
         * @param {string} bindingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBindingBindingsBindingIdDelete(bindingId: string, options?: any): AxiosPromise<any> {
            return localVarFp.removeBindingBindingsBindingIdDelete(bindingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BindingsApi - object-oriented interface
 * @export
 * @class BindingsApi
 * @extends {BaseAPI}
 */
export class BindingsApi extends BaseAPI {
    /**
     * 
     * @summary Binding Category Update
     * @param {string} bindingId 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId: string, categoryId: string, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).bindingCategoryUpdateBindingsBindingIdCategoryAssignCategoryIdPut(bindingId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Binding
     * @param {File} audio 
     * @param {string} [category] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public createBindingBindingsPost(audio: File, category?: string, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).createBindingBindingsPost(audio, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Bindings
     * @param {string} [category] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public getAllBindingsBindingsAllGet(category?: string, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).getAllBindingsBindingsAllGet(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Binding
     * @param {string} bindingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public getBindingBindingsBindingIdGet(bindingId: string, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).getBindingBindingsBindingIdGet(bindingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public getCountBindingsCountGet(options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).getCountBindingsCountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Paginated Bindings
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public getPaginatedBindingsBindingsGet(page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).getPaginatedBindingsBindingsGet(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Binding
     * @param {string} bindingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BindingsApi
     */
    public removeBindingBindingsBindingIdDelete(bindingId: string, options?: RawAxiosRequestConfig) {
        return BindingsApiFp(this.configuration).removeBindingBindingsBindingIdDelete(bindingId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get All Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategoriesCategoriesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post New Category
         * @param {string} category 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewCategoryCategoriesPost: async (category: string, id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('postNewCategoryCategoriesPost', 'category', category)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


            if (category !== undefined) { 
                localVarFormParams.set('category', category as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCategoryCategoriesCategoryNameDelete: async (categoryName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('removeCategoryCategoriesCategoryNameDelete', 'categoryName', categoryName)
            const localVarPath = `/categories/{category_name}`
                .replace(`{${"category_name"}}`, encodeURIComponent(String(categoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Category
         * @param {string} categoryName 
         * @param {string} newCategoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryCategoriesCategoryNamePatch: async (categoryName: string, newCategoryName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryName' is not null or undefined
            assertParamExists('updateCategoryCategoriesCategoryNamePatch', 'categoryName', categoryName)
            // verify required parameter 'newCategoryName' is not null or undefined
            assertParamExists('updateCategoryCategoriesCategoryNamePatch', 'newCategoryName', newCategoryName)
            const localVarPath = `/categories/{category_name}`
                .replace(`{${"category_name"}}`, encodeURIComponent(String(categoryName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (newCategoryName !== undefined) { 
                localVarFormParams.set('new_category_name', newCategoryName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get All Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategoriesCategoriesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategoriesCategoriesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.getAllCategoriesCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Post New Category
         * @param {string} category 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewCategoryCategoriesPost(category: string, id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewCategoryCategoriesPost(category, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.postNewCategoryCategoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCategoryCategoriesCategoryNameDelete(categoryName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCategoryCategoriesCategoryNameDelete(categoryName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.removeCategoryCategoriesCategoryNameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Category
         * @param {string} categoryName 
         * @param {string} newCategoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategoryCategoriesCategoryNamePatch(categoryName: string, newCategoryName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategoryCategoriesCategoryNamePatch(categoryName, newCategoryName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.updateCategoryCategoriesCategoryNamePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Get All Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategoriesCategoriesGet(options?: any): AxiosPromise<Array<CategoryModel>> {
            return localVarFp.getAllCategoriesCategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post New Category
         * @param {string} category 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewCategoryCategoriesPost(category: string, id?: string, options?: any): AxiosPromise<any> {
            return localVarFp.postNewCategoryCategoriesPost(category, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Category
         * @param {string} categoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCategoryCategoriesCategoryNameDelete(categoryName: string, options?: any): AxiosPromise<any> {
            return localVarFp.removeCategoryCategoriesCategoryNameDelete(categoryName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Category
         * @param {string} categoryName 
         * @param {string} newCategoryName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryCategoriesCategoryNamePatch(categoryName: string, newCategoryName: string, options?: any): AxiosPromise<any> {
            return localVarFp.updateCategoryCategoriesCategoryNamePatch(categoryName, newCategoryName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @summary Get All Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getAllCategoriesCategoriesGet(options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).getAllCategoriesCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post New Category
     * @param {string} category 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public postNewCategoryCategoriesPost(category: string, id?: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).postNewCategoryCategoriesPost(category, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Category
     * @param {string} categoryName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public removeCategoryCategoriesCategoryNameDelete(categoryName: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).removeCategoryCategoriesCategoryNameDelete(categoryName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Category
     * @param {string} categoryName 
     * @param {string} newCategoryName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public updateCategoryCategoriesCategoryNamePatch(categoryName: string, newCategoryName: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).updateCategoryCategoriesCategoryNamePatch(categoryName, newCategoryName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextsApi - axios parameter creator
 * @export
 */
export const TextsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get All Texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTextsTextsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/texts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Text
         * @param {string} textId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextTextsTextIdGet: async (textId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('getTextTextsTextIdGet', 'textId', textId)
            const localVarPath = `/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post New Text
         * @param {string} id 
         * @param {string} text 
         * @param {any} [commit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewTextTextsPost: async (id: string, text: string, commit?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postNewTextTextsPost', 'id', id)
            // verify required parameter 'text' is not null or undefined
            assertParamExists('postNewTextTextsPost', 'text', text)
            const localVarPath = `/texts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (commit !== undefined) {
                for (const [key, value] of Object.entries(commit)) {
                    localVarQueryParameter[key] = value;
                }
            }


            if (text !== undefined) { 
                localVarFormParams.set('text', text as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Text
         * @param {string} textId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTextTextsTextIdDelete: async (textId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('removeTextTextsTextIdDelete', 'textId', textId)
            const localVarPath = `/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Text
         * @param {string} textId 
         * @param {string} newText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextTextsTextIdPatch: async (textId: string, newText: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('updateTextTextsTextIdPatch', 'textId', textId)
            // verify required parameter 'newText' is not null or undefined
            assertParamExists('updateTextTextsTextIdPatch', 'newText', newText)
            const localVarPath = `/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (newText !== undefined) {
                localVarQueryParameter['new_text'] = newText;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextsApi - functional programming interface
 * @export
 */
export const TextsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get All Texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTextsTextsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTextsTextsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextsApi.getAllTextsTextsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Text
         * @param {string} textId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTextTextsTextIdGet(textId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTextTextsTextIdGet(textId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextsApi.getTextTextsTextIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Post New Text
         * @param {string} id 
         * @param {string} text 
         * @param {any} [commit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postNewTextTextsPost(id: string, text: string, commit?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postNewTextTextsPost(id, text, commit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextsApi.postNewTextTextsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Text
         * @param {string} textId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTextTextsTextIdDelete(textId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTextTextsTextIdDelete(textId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextsApi.removeTextTextsTextIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Text
         * @param {string} textId 
         * @param {string} newText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTextTextsTextIdPatch(textId: string, newText: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTextTextsTextIdPatch(textId, newText, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextsApi.updateTextTextsTextIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextsApi - factory interface
 * @export
 */
export const TextsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get All Texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTextsTextsGet(options?: any): AxiosPromise<any> {
            return localVarFp.getAllTextsTextsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Text
         * @param {string} textId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextTextsTextIdGet(textId: string, options?: any): AxiosPromise<TextModel> {
            return localVarFp.getTextTextsTextIdGet(textId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post New Text
         * @param {string} id 
         * @param {string} text 
         * @param {any} [commit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNewTextTextsPost(id: string, text: string, commit?: any, options?: any): AxiosPromise<any> {
            return localVarFp.postNewTextTextsPost(id, text, commit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Text
         * @param {string} textId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTextTextsTextIdDelete(textId: string, options?: any): AxiosPromise<any> {
            return localVarFp.removeTextTextsTextIdDelete(textId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Text
         * @param {string} textId 
         * @param {string} newText 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextTextsTextIdPatch(textId: string, newText: string, options?: any): AxiosPromise<any> {
            return localVarFp.updateTextTextsTextIdPatch(textId, newText, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextsApi - object-oriented interface
 * @export
 * @class TextsApi
 * @extends {BaseAPI}
 */
export class TextsApi extends BaseAPI {
    /**
     * 
     * @summary Get All Texts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public getAllTextsTextsGet(options?: RawAxiosRequestConfig) {
        return TextsApiFp(this.configuration).getAllTextsTextsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Text
     * @param {string} textId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public getTextTextsTextIdGet(textId: string, options?: RawAxiosRequestConfig) {
        return TextsApiFp(this.configuration).getTextTextsTextIdGet(textId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post New Text
     * @param {string} id 
     * @param {string} text 
     * @param {any} [commit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public postNewTextTextsPost(id: string, text: string, commit?: any, options?: RawAxiosRequestConfig) {
        return TextsApiFp(this.configuration).postNewTextTextsPost(id, text, commit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Text
     * @param {string} textId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public removeTextTextsTextIdDelete(textId: string, options?: RawAxiosRequestConfig) {
        return TextsApiFp(this.configuration).removeTextTextsTextIdDelete(textId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Text
     * @param {string} textId 
     * @param {string} newText 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public updateTextTextsTextIdPatch(textId: string, newText: string, options?: RawAxiosRequestConfig) {
        return TextsApiFp(this.configuration).updateTextTextsTextIdPatch(textId, newText, options).then((request) => request(this.axios, this.basePath));
    }
}



